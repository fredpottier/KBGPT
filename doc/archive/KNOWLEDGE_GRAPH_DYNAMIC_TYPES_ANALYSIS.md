# Analyse : Gestion Dynamique des Types d'Entit√©s - Vision vs Impl√©mentation Actuelle

**Date** : 2025-10-06
**Objectif** : Comparer la vision fonctionnelle cible avec l'impl√©mentation actuelle et identifier les √©carts

---

## üéØ Vision Fonctionnelle Cible

### 1. Gestion des Entity Types

#### √âtat Initial (Bootstrap)
- ‚úÖ Le syst√®me **peut** poss√©der des types d'entit√©s de base (non obligatoire)
- ‚úÖ Types stock√©s dans enum `EntityType` pour bootstrap uniquement
- ‚úÖ Types actuels : SOLUTION, COMPONENT, ORGANIZATION, PERSON, TECHNOLOGY, CONCEPT

#### D√©couverte Dynamique de Nouveaux Types
Lors de l'import d'un document :

1. **LLM identifie une entit√© avec un type** (ex: `entity_type: "INFRASTRUCTURE"`)

2. **Syst√®me v√©rifie si le type existe d√©j√†** :
   - ‚úÖ **Si type existe** ‚Üí rattacher l'entit√© √† ce type
   - ‚ùå **Si type n'existe PAS** ‚Üí **cr√©er automatiquement le nouveau type** et y rattacher l'entit√©

3. **Stockage des types dynamiques** :
   - ‚ùì √Ä d√©finir : YAML, BDD (Neo4j/PostgreSQL), JSON ?
   - Chaque type doit avoir : `name`, `status` (pending/approved), `created_at`, `entity_count`

#### Workflow de Validation (Frontend Admin)

**Page : Types d'Entit√©s**
- Afficher tous les types (valid√©s + pending)
- Pour chaque type en attente :

  **Option 1 : Accepter**
  - Type devient "official/approved"
  - Entit√©s associ√©es passent de "pending" ‚Üí "validated"

  **Option 2 : Fusionner (Redondant)**
  - S√©lectionner un type existant cible
  - Transf√©rer toutes les entit√©s vers le type cible
  - Supprimer le type en doublon

  **Option 3 : Rejeter**
  - Supprimer le type
  - **Cascade delete** : supprimer toutes les entit√©s et relations associ√©es

---

### 2. Gestion des Entit√©s (avec Normalisation)

#### Pipeline d'Insertion

1. **LLM extrait entit√©** : `{name: "S/4HANA PCE", entity_type: "SOLUTION"}`

2. **Normalisation du nom** (via `entity_normalizer.py`) :
   - Recherche dans dictionnaire d'ontologie du type (`config/ontologies/solutions.yaml`)
   - Si alias trouv√© ‚Üí utiliser `canonical_name` (`"SAP S/4HANA Cloud, Private Edition"`)
   - Si non trouv√© ‚Üí utiliser nom brut LLM + **marquer entit√© comme `status: "pending"`**

3. **V√©rification unicit√© dans Neo4j** :
   - Crit√®re : `(canonical_name, entity_type, tenant_id)`
   - Si existe d√©j√† ‚Üí **r√©utiliser l'entit√© existante** (pas de duplication)
   - Si n'existe pas ‚Üí cr√©er nouvelle entit√©

4. **Mise √† jour des relations** :
   - Les relations utilisent toujours les noms canoniques
   - Si entit√© r√©utilis√©e, relations sont cr√©√©es normalement

#### Workflow de Validation (Frontend Admin)

**Page : Entit√©s en Attente de Validation**

**Filtres** :
- Par type d'entit√© (SOLUTION, INFRASTRUCTURE, etc.)
- Status : pending uniquement (exclure entit√©s normalis√©es automatiquement)

**Pour chaque entit√© pending** :

**Option 1 : Valider**
- Passer `status: "pending"` ‚Üí `"validated"`
- Ajouter √† l'ontologie YAML correspondante

**Option 2 : Fusionner**
- S√©lectionner une entit√© existante cible
- Transf√©rer toutes les relations vers entit√© cible
- Supprimer entit√© en doublon

**Option 3 : Rejeter**
- Supprimer l'entit√©
- **Cascade delete** : supprimer relations associ√©es

---

## üîç Impl√©mentation Actuelle

### ‚úÖ Ce qui fonctionne d√©j√†

#### 1. Types Dynamiques (depuis derni√®re session)
```python
# src/knowbase/api/schemas/knowledge_graph.py:25
entity_type: str  # Accepte n'importe quel type (pas d'enum strict)
```
‚úÖ Le LLM peut renvoyer `INFRASTRUCTURE`, `NETWORK`, etc. ‚Üí accept√©

#### 2. Normalisation des Noms
```python
# src/knowbase/common/entity_normalizer.py:38-81
def normalize_entity_name(raw_name: str, entity_type: EntityType) -> Tuple[Optional[str], str]:
    # Retourne (entity_id, canonical_name)
    # Si pas dans dictionnaire ‚Üí (None, raw_name.strip())
```
‚úÖ Fonctionne avec dictionnaires YAML d'ontologie
‚úÖ Log des entit√©s non catalogu√©es dans `uncataloged_entities.log`

#### 3. Get or Create (√âviter Doublons)
```python
# src/knowbase/api/services/knowledge_graph_service.py:141-300
def get_or_create_entity(entity: EntityCreate) -> EntityResponse:
    # MATCH sur (name, entity_type, tenant_id)
    # Si existe ‚Üí retourne entit√© existante
    # Sinon ‚Üí CREATE nouvelle entit√©
```
‚úÖ R√©utilise entit√©s existantes correctement

#### 4. Relations sur Entit√©s R√©utilis√©es
```python
# src/knowbase/api/services/knowledge_graph_service.py:304-384
def create_relation(relation: RelationCreate) -> RelationResponse:
    # MATCH sur (source_name, target_name, tenant_id)
    # CREATE relation entre entit√©s (existantes ou nouvelles)
```
‚úÖ Relations cr√©√©es m√™me si entit√©s pr√©-existantes

---

### ‚ùå √âcarts et Manques Critiques

#### 1. **Gestion des Entity Types Dynamiques**

**Probl√®me** :
- ‚úÖ Types dynamiques accept√©s (string au lieu d'enum)
- ‚ùå **Aucun stockage structur√© des types d√©couverts**
- ‚ùå **Pas de statut `pending/approved` sur les types**
- ‚ùå **Impossible de lister les types existants**

**Impact** :
- Impossible de savoir quels types ont √©t√© d√©couverts
- Impossible de valider/rejeter un type
- Impossible de fusionner types redondants

**Solution requise** :
```python
# Nouvelle table/collection : entity_types_registry
{
    "type_name": "INFRASTRUCTURE",
    "status": "pending",  # pending | approved | rejected
    "first_seen": "2025-10-06T10:30:00Z",
    "entity_count": 40,
    "created_by": "llm",  # llm | admin
    "approved_by": null,
    "approved_at": null
}
```

**Stockage possible** :
- **Option A** : Table PostgreSQL `entity_types`
- **Option B** : Nodes Neo4j `:EntityType`
- **Option C** : Fichier YAML dynamique `config/ontologies/discovered_types.yaml`

---

#### 2. **Statut `pending` sur Entit√©s**

**Probl√®me** :
- ‚úÖ Normalisation identifie entit√©s non catalogu√©es
- ‚úÖ Log dans `uncataloged_entities.log`
- ‚ùå **Aucun champ `status` dans EntityCreate/EntityResponse**
- ‚ùå **Impossible de distinguer dans Neo4j** :
  - Entit√©s normalis√©es automatiquement (ex: "S/4HANA PCE" ‚Üí canonical)
  - Entit√©s non catalogu√©es en attente validation (ex: "Azure VNET" nouveau)

**Impact** :
- Frontend ne peut pas afficher uniquement les entit√©s "pending"
- Impossible de filtrer/valider les entit√©s non catalogu√©es

**Solution requise** :
```python
# src/knowbase/api/schemas/knowledge_graph.py
class EntityCreate(BaseModel):
    # ... champs existants ...
    status: str = Field(
        default="pending",  # pending | validated | rejected
        description="Statut validation entit√©"
    )
    is_cataloged: bool = Field(
        default=False,
        description="True si trouv√© dans ontologie YAML"
    )
```

**Modification service** :
```python
# src/knowbase/api/services/knowledge_graph_service.py:141-195
def get_or_create_entity(entity: EntityCreate) -> EntityResponse:
    # Normaliser
    entity_id, canonical_name = self.normalizer.normalize_entity_name(...)

    if entity_id:
        entity.status = "validated"  # Trouv√© dans ontologie
        entity.is_cataloged = True
    else:
        entity.status = "pending"    # Non catalogu√©
        entity.is_cataloged = False

    # Reste du code...
```

---

#### 3. **API de Gestion des Types (Backend)**

**Manque** : Endpoints FastAPI pour admin frontend

**Requis** :
```python
# src/knowbase/api/routers/entity_types.py (nouveau fichier)

@router.get("/entity-types", response_model=List[EntityTypeResponse])
async def list_entity_types(
    status: Optional[str] = None,  # pending | approved
    tenant_id: str = "default"
):
    """Liste tous les types d'entit√©s (d√©couverts + bootstrap)."""
    pass

@router.post("/entity-types/{type_name}/approve")
async def approve_entity_type(type_name: str, tenant_id: str = "default"):
    """Valide un type d√©couvert ‚Üí status = approved."""
    pass

@router.post("/entity-types/{type_name}/merge")
async def merge_entity_type(
    type_name: str,
    target_type: str,
    tenant_id: str = "default"
):
    """Fusionne type redondant vers type existant."""
    # 1. Transf√©rer toutes les entit√©s vers target_type
    # 2. Supprimer type_name
    pass

@router.delete("/entity-types/{type_name}")
async def reject_entity_type(type_name: str, tenant_id: str = "default"):
    """Rejette type ‚Üí cascade delete entit√©s/relations."""
    pass
```

---

#### 4. **API de Gestion des Entit√©s (Backend)**

**Manque** : Endpoints pour entit√©s pending

**Requis** :
```python
# src/knowbase/api/routers/entities.py (nouveau fichier)

@router.get("/entities/pending", response_model=List[EntityResponse])
async def list_pending_entities(
    entity_type: Optional[str] = None,
    tenant_id: str = "default"
):
    """Liste entit√©s en attente de validation (status=pending)."""
    pass

@router.post("/entities/{entity_uuid}/approve")
async def approve_entity(entity_uuid: str):
    """Valide entit√© ‚Üí status = validated + ajout ontologie YAML."""
    pass

@router.post("/entities/{entity_uuid}/merge")
async def merge_entity(
    entity_uuid: str,
    target_entity_uuid: str
):
    """Fusionne entit√© vers entit√© existante."""
    # 1. Transf√©rer relations vers target
    # 2. Supprimer entit√© source
    pass

@router.delete("/entities/{entity_uuid}")
async def reject_entity(entity_uuid: str):
    """Rejette entit√© ‚Üí cascade delete relations."""
    pass
```

---

#### 5. **Requ√™tes Neo4j Manquantes**

**Pour types** :
```cypher
// Lister types d√©couverts avec comptage
MATCH (e:Entity)
WHERE e.tenant_id = $tenant_id
RETURN DISTINCT e.entity_type AS type_name,
       COUNT(e) AS entity_count
ORDER BY entity_count DESC;

// Supprimer type + cascade
MATCH (e:Entity {entity_type: $type_name, tenant_id: $tenant_id})
OPTIONAL MATCH (e)-[r:RELATION]-()
DELETE r, e;
```

**Pour entit√©s** :
```cypher
// Lister entit√©s pending
MATCH (e:Entity)
WHERE e.status = 'pending' AND e.tenant_id = $tenant_id
RETURN e;

// Fusionner entit√©s (transf√©rer relations)
MATCH (source:Entity {uuid: $source_uuid})
MATCH (target:Entity {uuid: $target_uuid})
MATCH (source)-[r:RELATION]-(other)
CREATE (target)-[r2:RELATION {r}]-(other)
DELETE r, source;
```

---

#### 6. **Frontend Admin (Pages Manquantes)**

**Page 1 : Gestion Types d'Entit√©s** (`/admin/entity-types`)
- Tableau : type_name | status | entity_count | first_seen | actions
- Filtres : status (pending/approved)
- Actions : Approve | Merge ‚Üí Type | Delete

**Page 2 : Gestion Entit√©s Pending** (`/admin/entities/pending`)
- Tableau : name | entity_type | source_document | created_at | actions
- Filtres : entity_type
- Actions : Approve | Merge ‚Üí Entity | Delete

**Page 3 : Dictionnaires Ontologie** (`/admin/ontologies`)
- √âdition YAML des dictionnaires
- Ajout manuel aliases
- Preview canonicalisation

---

## üìã Plan de Migration

### Phase 1 : Stockage Types Dynamiques (Backend)
1. ‚úÖ Accepter types string (FAIT dans session pr√©c√©dente)
2. ‚ùå Ajouter table/collection `entity_types_registry`
3. ‚ùå Modifier `get_or_create_entity` pour enregistrer types d√©couverts

### Phase 2 : Statut Entit√©s (Backend)
1. ‚ùå Ajouter champs `status`, `is_cataloged` √† EntityCreate/Response
2. ‚ùå Modifier Neo4j CREATE queries pour stocker status
3. ‚ùå Modifier `entity_normalizer` pour d√©finir status selon catalogage

### Phase 3 : API Administration (Backend)
1. ‚ùå Router `/entity-types` (CRUD types)
2. ‚ùå Router `/entities/pending` (CRUD entit√©s)
3. ‚ùå Service Neo4j pour merge/cascade delete

### Phase 4 : Frontend Admin
1. ‚ùå Page gestion types (`/admin/entity-types`)
2. ‚ùå Page gestion entit√©s pending (`/admin/entities/pending`)
3. ‚ùå Page √©dition ontologies (`/admin/ontologies`)

---

## üö® Impacts sur Fonctionnement Actuel

### Ce qui fonctionne correctement
‚úÖ Normalisation noms via ontologies YAML
‚úÖ Get or create √©vite doublons
‚úÖ Relations cr√©√©es sur entit√©s r√©utilis√©es
‚úÖ Types dynamiques accept√©s (INFRASTRUCTURE, etc.)

### Ce qui NE fonctionne PAS comme attendu
‚ùå **Entit√©s normalis√©es stock√©es sans distinction** :
   - "S/4HANA PCE" ‚Üí "SAP S/4HANA Cloud, Private Edition" (OK)
   - "Azure VNET" ‚Üí "Azure VNET" (pas de statut pending)

‚ùå **Types d√©couverts non track√©s** :
   - INFRASTRUCTURE cr√©√© mais pas enregistr√© comme nouveau type

‚ùå **Impossible de valider/rejeter** :
   - Pas d'interface admin
   - Pas de requ√™tes Neo4j adapt√©es

---

## ‚úÖ Recommandations

### Approche 1 : Migration Compl√®te (Recommand√©e)
- Impl√©menter Phases 1-4 compl√®tes
- Dur√©e estim√©e : 3-4 jours
- B√©n√©fice : Syst√®me conforme √† vision compl√®te

### Approche 2 : Incr√©mentale (Pragmatique)
1. **Court terme** (1j) :
   - Ajouter champ `status` entit√©s
   - Modifier normalizer pour d√©finir status
   - API simple pour lister pending

2. **Moyen terme** (2j) :
   - Stockage types d√©couverts
   - API gestion types

3. **Long terme** (2j) :
   - Frontend admin complet
   - Workflow validation/merge

### Approche 3 : Report
- Continuer avec syst√®me actuel
- Log dans `uncataloged_entities.log`
- Migration admin plus tard

---

## üìä R√©sum√© √âcarts

| Fonctionnalit√© | Vision | Actuel | √âcart |
|---------------|--------|--------|-------|
| Types dynamiques accept√©s | ‚úÖ | ‚úÖ | ‚úÖ OK |
| Stockage types d√©couverts | ‚úÖ | ‚ùå | üî¥ Manquant |
| Statut pending entit√©s | ‚úÖ | ‚ùå | üî¥ Manquant |
| Normalisation noms | ‚úÖ | ‚úÖ | ‚úÖ OK |
| Get or create | ‚úÖ | ‚úÖ | ‚úÖ OK |
| Relations sur r√©utilis√©es | ‚úÖ | ‚úÖ | ‚úÖ OK |
| API admin types | ‚úÖ | ‚ùå | üî¥ Manquant |
| API admin entit√©s | ‚úÖ | ‚ùå | üî¥ Manquant |
| Frontend admin | ‚úÖ | ‚ùå | üî¥ Manquant |
| Merge/cascade delete | ‚úÖ | ‚ùå | üî¥ Manquant |

**Score conformit√© : 4/10** ‚úÖ
**√âl√©ments critiques manquants : 6/10** üî¥

---

**Prochaine √©tape recommand√©e** : Valider l'approche de stockage des types (PostgreSQL vs Neo4j vs YAML) avant d'impl√©menter Phase 1.
