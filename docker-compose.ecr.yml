# Docker Compose pour déploiement AWS EC2 avec images ECR
# Usage: docker-compose -f docker-compose.ecr.yml up -d
# Prerequisite: AWS CLI configuré + images dans ECR + .env configuré
#
# IMPORTANT: Utilisez .env.ecr.example comme template pour votre .env

version: '3.8'

x-common-config: &common-config
  stop_grace_period: 10s
  restart: unless-stopped

services:
  # ===================================
  # KNOWLEDGE GRAPH - Neo4j (depuis ECR)
  # ===================================
  neo4j:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-neo4j:latest
    container_name: knowbase-neo4j
    ports:
      - "7474:7474"  # HTTP Browser UI
      - "7687:7687"  # Bolt protocol
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
    environment:
      # Authentication
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD:-neo4j_password}
      # Memory configuration (optimisé pour EC2 t3.xlarge+)
      - NEO4J_server_memory_heap_initial__size=1g
      - NEO4J_server_memory_heap_max__size=4g
      - NEO4J_server_memory_pagecache_size=2g
      # Security
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
      - NEO4J_dbms_security_procedures_allowlist=apoc.*
    networks:
      - knowbase_net
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:7474 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s

  # ===================================
  # VECTOR DATABASE - Qdrant (depuis ECR)
  # ===================================
  qdrant:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-qdrant:latest
    container_name: knowbase-qdrant
    ports:
      - "6333:6333"
      - "6334:6334"  # gRPC port
    volumes:
      - qdrant_data:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
      - QDRANT__STORAGE__CHECK_FS=false
      - QDRANT__STORAGE__STRICT=false
      - QDRANT__LOG_LEVEL=INFO
    networks:
      - knowbase_net
    # Health check desactive: image Qdrant de base ne contient pas wget/curl
    # Qdrant demarre rapidement (~5-10s), un delai fixe suffit
    healthcheck:
      test: ["CMD-SHELL", "exit 0"]
      interval: 30s
      timeout: 10s
      retries: 1
      start_period: 15s

  # ===================================
  # CACHE & QUEUE - Redis (depuis ECR)
  # ===================================
  redis:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-redis:latest
    container_name: knowbase-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --maxmemory 2gb --maxmemory-policy allkeys-lru
    networks:
      - knowbase_net
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # ===================================
  # BACKEND API - FastAPI (depuis ECR)
  # ===================================
  app:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-app:latest
    container_name: knowbase-app
    depends_on:
      neo4j:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      PYTHONPATH: /app:/app/src
      HF_HOME: /data/models
      KNOWBASE_DATA_DIR: /data
      REDIS_URL: redis://redis:6379/0
      NEO4J_URI: bolt://neo4j:7687
      NEO4J_USER: neo4j
      NEO4J_PASSWORD: ${NEO4J_PASSWORD}
      QDRANT_HOST: qdrant
      QDRANT_PORT: 6333
      CORS_ORIGINS: ${CORS_ORIGINS:-}
      # JWT keys paths (mounted from ./config to /app/config in container)
      JWT_PRIVATE_KEY_PATH: /app/config/keys/jwt_private.pem
      JWT_PUBLIC_KEY_PATH: /app/config/keys/jwt_public.pem
    ports:
      - "${APP_PORT:-8000}:8000"
    volumes:
      - app_data:/data
      - app_models:/data/models
      - app_logs:/data/logs  # Logs séparés pour Promtail
      - ./config:/app/config:ro  # Read-only config mount (relatif à working_dir /app)
    networks:
      - knowbase_net
    working_dir: /app
    # Production mode: 4 workers uvicorn
    command: python -m uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/docs"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G

  # ===================================
  # INGESTION WORKER - RQ Worker (depuis ECR)
  # ===================================
  ingestion-worker:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-worker:latest
    container_name: knowbase-worker
    depends_on:
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
      qdrant:
        condition: service_healthy
    stop_grace_period: 30s
    env_file:
      - .env
    environment:
      PYTHONPATH: /app:/app/src
      HF_HOME: /data/models
      KNOWBASE_DATA_DIR: /data
      REDIS_URL: redis://redis:6379/0
      NEO4J_URI: bolt://neo4j:7687
      NEO4J_USER: neo4j
      NEO4J_PASSWORD: ${NEO4J_PASSWORD}
      QDRANT_HOST: qdrant
      QDRANT_PORT: 6333
      DEV_MODE: "false"  # Mode production
      WORKER_CONCURRENCY: "4"  # Jobs par worker (garder 4)
      # Performance mono-document (parallélisation interne)
      MAX_PARALLEL_SEGMENTS: "${MAX_PARALLEL_SEGMENTS:-5}"  # Segments en parallèle
      OPENAI_MAX_RPM: "${OPENAI_MAX_RPM:-500}"  # Rate limit OpenAI
      # JWT keys paths (mounted from ./config to /app/config in container)
      JWT_PRIVATE_KEY_PATH: /app/config/keys/jwt_private.pem
      JWT_PUBLIC_KEY_PATH: /app/config/keys/jwt_public.pem
    volumes:
      - app_data:/data  # PARTAGE du volume avec app pour accéder aux fichiers uploadés
      - app_models:/data/models  # Partage des modèles avec app
      - app_logs:/data/logs  # Logs séparés pour Promtail
      - ./config:/app/config:ro  # Read-only config mount (relatif à working_dir /app)
    networks:
      - knowbase_net
    working_dir: /app
    command: python -m knowbase.ingestion.queue
    deploy:
      resources:
        limits:
          cpus: '6.0'  # Augmenté pour parallélisation (8 vCPU - 2 pour système)
          memory: 16G  # Augmenté pour traiter 5 segments en parallèle
        reservations:
          cpus: '4.0'
          memory: 8G

  # ===================================
  # LEGACY UI - Streamlit (depuis ECR)
  # ===================================
  ui:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-ui:latest
    container_name: knowbase-ui
    depends_on:
      app:
        condition: service_healthy
    env_file:
      - .env
    environment:
      BACKEND_URL: http://app:8000
      PYTHONPATH: /app/src
      KNOWBASE_DATA_DIR: /data
    ports:
      - "${APP_UI_PORT:-8501}:8501"
    volumes:
      - ui_data:/data
      - ./config:/app/config:ro
    networks:
      - knowbase_net
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8501/_stcore/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===================================
  # FRONTEND - Next.js (depuis ECR)
  # ===================================
  frontend:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-frontend:latest
    container_name: knowbase-frontend
    depends_on:
      app:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - NEXT_TELEMETRY_DISABLED=1
      # IMPORTANT: NEXT_PUBLIC_* vars sont compilees dans l'image Docker (build time)
      # Ne PAS les override ici, elles sont deja /api dans l'image
      - NEXT_PUBLIC_API_INTERNAL_URL=http://app:8000
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    networks:
      - knowbase_net
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G

  # ===================================
  # NGINX - Reverse Proxy (EC2 uniquement)
  # ===================================
  nginx:
    <<: *common-config
    image: nginx:1.25-alpine
    container_name: knowbase-nginx
    depends_on:
      frontend:
        condition: service_healthy
      app:
        condition: service_healthy
      grafana:
        condition: service_healthy
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "80:80"
    networks:
      - knowbase_net
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M

  # ===================================
  # NGROK - Tunnel (optionnel, depuis ECR)
  # ===================================
  # Décommentez si vous voulez exposer votre EC2 via ngrok
  # ngrok:
  #   <<: *common-config
  #   image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-ngrok:latest
  #   container_name: knowbase-ngrok
  #   depends_on:
  #     - app
  #     - frontend
  #   volumes:
  #     - ./ngrok.yml:/etc/ngrok.yml:ro
  #     - ngrok_logs:/logs
  #   env_file:
  #     - .env
  #   command: start --config /etc/ngrok.yml --all
  #   networks:
  #     - knowbase_net

  # ===================================
  # MONITORING - Loki (Log Aggregation)
  # ===================================
  loki:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-loki:latest
    container_name: knowbase-loki
    ports:
      - "3100:3100"
    volumes:
      - ./monitoring/loki-config.yml:/etc/loki/local-config.yaml:ro
      - loki_data:/loki
    command: -config.file=/etc/loki/local-config.yaml
    networks:
      - knowbase_net
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3100/ready || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===================================
  # MONITORING - Promtail (Log Collector)
  # ===================================
  promtail:
    <<: *common-config
    image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/sap-kb-promtail:latest
    container_name: knowbase-promtail
    volumes:
      - ./monitoring/promtail-config.yml:/etc/promtail/config.yml:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - app_logs:/data/logs:ro  # Volume partagé avec app/worker (lecture seule)
    command: -config.file=/etc/promtail/config.yml
    networks:
      - knowbase_net
    depends_on:
      - loki

networks:
  knowbase_net:
    name: knowbase_network
    driver: bridge

volumes:
  neo4j_data:
    name: knowbase_neo4j_data
  neo4j_logs:
    name: knowbase_neo4j_logs
  qdrant_data:
    name: knowbase_qdrant_data
  redis_data:
    name: knowbase_redis_data
  loki_data:
    name: knowbase_loki_data
  grafana_data:
    name: knowbase_grafana_data
  app_data:
    name: knowbase_app_data
  app_models:
    name: knowbase_app_models
  app_logs:
    name: knowbase_app_logs
  ui_data:
    name: knowbase_ui_data
  # ngrok_logs:
  #   name: knowbase_ngrok_logs