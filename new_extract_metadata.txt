def extract_pptx_metadata(pptx_path: Path) -> dict:
    """
    Extrait les m√©tadonn√©es depuis le fichier PPTX (docProps/core.xml + app.xml).

    Extrait notamment :
    - Date de modification (source_date)
    - Titre, cr√©ateur, version
    - Last modified by, reviewers (si disponibles)

    Args:
        pptx_path: Chemin vers le fichier PPTX

    Returns:
        dict: M√©tadonn√©es extraites (titre, creator, source_date, version, etc.)
    """
    try:
        metadata = {}

        with zipfile.ZipFile(pptx_path, 'r') as pptx_zip:
            # === Extraction docProps/core.xml (m√©tadonn√©es standard) ===
            if 'docProps/core.xml' in pptx_zip.namelist():
                core_xml = pptx_zip.read('docProps/core.xml').decode('utf-8')
                root = ET.fromstring(core_xml)

                # Namespaces Office Open XML
                namespaces = {
                    'cp': 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
                    'dc': 'http://purl.org/dc/elements/1.1/',
                    'dcterms': 'http://purl.org/dc/terms/',
                    'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
                }

                # Date de modification (prioritaire pour source_date)
                modified_elem = root.find('dcterms:modified', namespaces)
                if modified_elem is not None and modified_elem.text:
                    try:
                        modified_str = modified_elem.text
                        modified_dt = datetime.fromisoformat(modified_str.replace('Z', '+00:00'))
                        metadata['source_date'] = modified_dt.strftime('%Y-%m-%d')
                        metadata['modified_at'] = modified_dt.isoformat()
                        logger.info(f"üìÖ Date de modification extraite: {metadata['source_date']}")
                    except Exception as e:
                        logger.warning(f"Erreur parsing date modification: {e}")

                # Date de cr√©ation
                created_elem = root.find('dcterms:created', namespaces)
                if created_elem is not None and created_elem.text:
                    try:
                        created_str = created_elem.text
                        created_dt = datetime.fromisoformat(created_str.replace('Z', '+00:00'))
                        metadata['created_at'] = created_dt.isoformat()
                        logger.debug(f"üìÖ Date de cr√©ation extraite: {created_dt.strftime('%Y-%m-%d')}")
                    except Exception as e:
                        logger.warning(f"Erreur parsing date cr√©ation: {e}")

                # Titre
                title_elem = root.find('dc:title', namespaces)
                if title_elem is not None and title_elem.text:
                    metadata['title'] = title_elem.text.strip()
                    logger.info(f"üìÑ Titre extrait: {metadata['title']}")

                # Cr√©ateur (auteur initial)
                creator_elem = root.find('dc:creator', namespaces)
                if creator_elem is not None and creator_elem.text:
                    metadata['creator'] = creator_elem.text.strip()
                    logger.info(f"üë§ Cr√©ateur extrait: {metadata['creator']}")

                # Last modified by (dernier modificateur)
                last_modified_by_elem = root.find('cp:lastModifiedBy', namespaces)
                if last_modified_by_elem is not None and last_modified_by_elem.text:
                    metadata['last_modified_by'] = last_modified_by_elem.text.strip()
                    logger.debug(f"üë§ Dernier modificateur: {metadata['last_modified_by']}")

                # Version (si pr√©sente)
                version_elem = root.find('cp:version', namespaces)
                if version_elem is not None and version_elem.text:
                    metadata['version'] = version_elem.text.strip()
                    logger.info(f"üîñ Version extraite: {metadata['version']}")

                # R√©vision (nombre de r√©visions)
                revision_elem = root.find('cp:revision', namespaces)
                if revision_elem is not None and revision_elem.text:
                    try:
                        metadata['revision'] = int(revision_elem.text)
                        logger.debug(f"üîÑ R√©vision: {metadata['revision']}")
                    except ValueError:
                        pass

                # Subject / Description
                subject_elem = root.find('dc:subject', namespaces)
                if subject_elem is not None and subject_elem.text:
                    metadata['subject'] = subject_elem.text.strip()
                    logger.debug(f"üìù Sujet: {metadata['subject']}")

                description_elem = root.find('dc:description', namespaces)
                if description_elem is not None and description_elem.text:
                    metadata['description'] = description_elem.text.strip()
                    logger.debug(f"üìù Description extraite ({len(metadata['description'])} chars)")

            else:
                logger.warning(f"Pas de m√©tadonn√©es core.xml dans {pptx_path.name}")

            # === Extraction docProps/app.xml (propri√©t√©s application) ===
            if 'docProps/app.xml' in pptx_zip.namelist():
                try:
                    app_xml = pptx_zip.read('docProps/app.xml').decode('utf-8')
                    app_root = ET.fromstring(app_xml)

                    # Namespace pour app.xml
                    app_ns = {
                        'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
                        'ap': 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties'
                    }

                    # Company (organisation)
                    company_elem = app_root.find('ap:Company', app_ns)
                    if company_elem is not None and company_elem.text:
                        metadata['company'] = company_elem.text.strip()
                        logger.debug(f"üè¢ Compagnie: {metadata['company']}")

                    # Manager (peut servir pour approver/reviewer)
                    manager_elem = app_root.find('ap:Manager', app_ns)
                    if manager_elem is not None and manager_elem.text:
                        metadata['manager'] = manager_elem.text.strip()
                        logger.debug(f"üëî Manager: {metadata['manager']}")

                except Exception as e:
                    logger.warning(f"Erreur parsing app.xml: {e}")

        # Fallback : Extraire version depuis filename si non trouv√©e dans metadata
        if 'version' not in metadata:
            import re
            # Pattern: fichier_v1.0.pptx, fichier_version_1.2.pptx, etc.
            version_match = re.search(r'v(\d+\.\d+)', pptx_path.name, re.IGNORECASE)
            if version_match:
                metadata['version'] = version_match.group(1)
                logger.info(f"üîñ Version extraite du filename: v{metadata['version']}")

        logger.info(f"‚úÖ M√©tadonn√©es extraites: {len(metadata)} champs ({', '.join(metadata.keys())})")
        return metadata

    except Exception as e:
        logger.warning(f"Erreur extraction m√©tadonn√©es PPTX {pptx_path.name}: {e}")
        return {}


# Analyse globale du deck pour extraire r√©sum√© et m√©tadonn√©es (document, solution)
